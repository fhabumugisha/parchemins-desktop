TASK 06 - SETTINGS, UX AND POLISH

You are completing development of "Assistant Pastoral", an Electron desktop application. This final task focuses on implementing the settings panel, onboarding experience, error handling, and UI polish.

PREREQUISITES

Tasks 01-05 must be completed. You should have:
- Complete project structure
- Text extractors
- Database with FTS5 search
- Document management UI
- AI chat functionality

OVERVIEW

Implement:
1. Settings panel with API key management
2. Secure API key storage using Electron's safeStorage
3. Onboarding flow for first launch
4. Error handling and user feedback
5. Accessibility features (font size, keyboard navigation)
6. UI polish and animations
7. About section

SECURE API KEY STORAGE

Create src/main/services/secure-storage.service.ts:

import { safeStorage } from "electron";
import { getSetting, setSetting, deleteSetting } from "./database.service";

const API_KEY_ENCRYPTED = "anthropic_api_key_encrypted";
const API_KEY_METHOD = "anthropic_api_key_method";
const API_KEY_PLAIN = "anthropic_api_key"; // Fallback if encryption unavailable

// Store API key securely
export function storeApiKey(key: string): void {
  if (safeStorage.isEncryptionAvailable()) {
    const encrypted = safeStorage.encryptString(key);
    setSetting(API_KEY_ENCRYPTED, encrypted.toString("base64"));
    setSetting(API_KEY_METHOD, "encrypted");
    // Remove any plain text key
    deleteSetting(API_KEY_PLAIN);
  } else {
    // Fallback to plain storage (less secure)
    console.warn("Encryption not available, storing API key in plain text");
    setSetting(API_KEY_PLAIN, key);
    setSetting(API_KEY_METHOD, "plain");
  }
}

// Retrieve API key
export function retrieveApiKey(): string | null {
  const method = getSetting(API_KEY_METHOD);
  
  if (method === "encrypted" && safeStorage.isEncryptionAvailable()) {
    const encrypted = getSetting(API_KEY_ENCRYPTED);
    if (encrypted) {
      try {
        const buffer = Buffer.from(encrypted, "base64");
        return safeStorage.decryptString(buffer);
      } catch (error) {
        console.error("Failed to decrypt API key:", error);
        return null;
      }
    }
  }
  
  // Fallback to plain storage
  return getSetting(API_KEY_PLAIN) || null;
}

// Check if API key is stored
export function hasApiKey(): boolean {
  const method = getSetting(API_KEY_METHOD);
  if (method === "encrypted") {
    return !!getSetting(API_KEY_ENCRYPTED);
  }
  return !!getSetting(API_KEY_PLAIN);
}

// Delete API key
export function deleteApiKey(): void {
  deleteSetting(API_KEY_ENCRYPTED);
  deleteSetting(API_KEY_PLAIN);
  deleteSetting(API_KEY_METHOD);
}

// Check if encryption is available
export function isEncryptionAvailable(): boolean {
  return safeStorage.isEncryptionAvailable();
}

UPDATE CLAUDE SERVICE

Update src/main/services/claude.service.ts to use secure storage:

import { retrieveApiKey, hasApiKey } from "./secure-storage.service";

// Replace getSetting("anthropic_api_key") with retrieveApiKey()
function getClient(): Anthropic {
  if (!client) {
    const apiKey = retrieveApiKey();
    if (!apiKey) {
      throw new Error("Cle API Anthropic non configuree.");
    }
    client = new Anthropic({ apiKey });
  }
  return client;
}

export function isApiKeyConfigured(): boolean {
  return hasApiKey();
}

SETTINGS IPC HANDLERS

Update src/main/ipc/settings.ipc.ts:

import { ipcMain, app } from "electron";
import { IPC_CHANNELS } from "../../shared/ipc-channels";
import * as db from "../services/database.service";
import { storeApiKey, retrieveApiKey, hasApiKey, deleteApiKey, isEncryptionAvailable } from "../services/secure-storage.service";
import { resetClaudeClient, testApiKey } from "../services/claude.service";

export function registerSettingsHandlers(): void {
  // Get setting
  ipcMain.handle(IPC_CHANNELS.SETTINGS_GET, async (_, key: string) => {
    return db.getSetting(key);
  });
  
  // Set setting
  ipcMain.handle(IPC_CHANNELS.SETTINGS_SET, async (_, key: string, value: string) => {
    db.setSetting(key, value);
    return { success: true };
  });
  
  // Get all settings
  ipcMain.handle(IPC_CHANNELS.SETTINGS_GET_ALL, async () => {
    const settings = db.getAllSettings();
    // Add computed settings
    return {
      ...settings,
      hasApiKey: hasApiKey(),
      isEncryptionAvailable: isEncryptionAvailable()
    };
  });
  
  // Save API key securely
  ipcMain.handle("settings:saveApiKey", async (_, apiKey: string) => {
    // Test the key first
    const isValid = await testApiKey(apiKey);
    if (!isValid) {
      throw new Error("Cle API invalide. Verifiez et reessayez.");
    }
    
    storeApiKey(apiKey);
    resetClaudeClient(); // Reset client to use new key
    return { success: true };
  });
  
  // Delete API key
  ipcMain.handle("settings:deleteApiKey", async () => {
    deleteApiKey();
    resetClaudeClient();
    return { success: true };
  });
  
  // Check if API key exists
  ipcMain.handle("settings:hasApiKey", async () => {
    return hasApiKey();
  });
  
  // Get app info
  ipcMain.handle("settings:getAppInfo", async () => {
    return {
      version: app.getVersion(),
      name: app.getName(),
      electronVersion: process.versions.electron,
      chromeVersion: process.versions.chrome,
      nodeVersion: process.versions.node
    };
  });
  
  // Credits
  ipcMain.handle(IPC_CHANNELS.CREDITS_GET, async () => {
    return db.getCredits();
  });
  
  ipcMain.handle(IPC_CHANNELS.CREDITS_PURCHASE, async (_, amount: number) => {
    return db.updateCredits(amount);
  });
}

UPDATE PRELOAD

Add to src/preload/index.ts:

settings: {
  get: (key: string) => ipcRenderer.invoke(IPC_CHANNELS.SETTINGS_GET, key),
  set: (key: string, value: string) => ipcRenderer.invoke(IPC_CHANNELS.SETTINGS_SET, key, value),
  getAll: () => ipcRenderer.invoke(IPC_CHANNELS.SETTINGS_GET_ALL),
  saveApiKey: (apiKey: string) => ipcRenderer.invoke("settings:saveApiKey", apiKey),
  deleteApiKey: () => ipcRenderer.invoke("settings:deleteApiKey"),
  hasApiKey: () => ipcRenderer.invoke("settings:hasApiKey"),
  getAppInfo: () => ipcRenderer.invoke("settings:getAppInfo"),
},

SETTINGS STORE

Create src/renderer/stores/settings.store.ts:

import { create } from "zustand";

interface AppInfo {
  version: string;
  name: string;
  electronVersion: string;
  chromeVersion: string;
  nodeVersion: string;
}

interface SettingsState {
  hasApiKey: boolean;
  isEncryptionAvailable: boolean;
  sermonsFolder: string | null;
  fontSize: "small" | "medium" | "large";
  appInfo: AppInfo | null;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  fetchSettings: () => Promise<void>;
  saveApiKey: (apiKey: string) => Promise<void>;
  deleteApiKey: () => Promise<void>;
  setFontSize: (size: "small" | "medium" | "large") => Promise<void>;
  fetchAppInfo: () => Promise<void>;
}

export const useSettingsStore = create<SettingsState>((set) => ({
  hasApiKey: false,
  isEncryptionAvailable: false,
  sermonsFolder: null,
  fontSize: "medium",
  appInfo: null,
  isLoading: false,
  error: null,
  
  fetchSettings: async () => {
    set({ isLoading: true });
    try {
      const settings = await window.electronAPI.settings.getAll();
      set({
        hasApiKey: settings.hasApiKey,
        isEncryptionAvailable: settings.isEncryptionAvailable,
        sermonsFolder: settings.sermons_folder || null,
        fontSize: (settings.font_size as any) || "medium",
        isLoading: false
      });
    } catch (error) {
      set({ error: (error as Error).message, isLoading: false });
    }
  },
  
  saveApiKey: async (apiKey) => {
    set({ isLoading: true, error: null });
    try {
      await window.electronAPI.settings.saveApiKey(apiKey);
      set({ hasApiKey: true, isLoading: false });
    } catch (error) {
      set({ error: (error as Error).message, isLoading: false });
      throw error;
    }
  },
  
  deleteApiKey: async () => {
    set({ isLoading: true });
    try {
      await window.electronAPI.settings.deleteApiKey();
      set({ hasApiKey: false, isLoading: false });
    } catch (error) {
      set({ error: (error as Error).message, isLoading: false });
    }
  },
  
  setFontSize: async (fontSize) => {
    await window.electronAPI.settings.set("font_size", fontSize);
    set({ fontSize });
  },
  
  fetchAppInfo: async () => {
    try {
      const appInfo = await window.electronAPI.settings.getAppInfo();
      set({ appInfo });
    } catch (error) {
      console.error("Failed to fetch app info:", error);
    }
  }
}));

SETTINGS PANEL

Create src/renderer/components/settings/SettingsPanel.tsx:

import React, { useEffect, useState } from "react";
import { ArrowLeft, Key, Folder, Type, Info, Shield, Trash2, CheckCircle, AlertTriangle } from "lucide-react";
import { useSettingsStore } from "../../stores/settings.store";
import { useUIStore } from "../../stores/ui.store";
import { useCreditsStore } from "../../stores/credits.store";
import { useIndexerStore } from "../../stores/indexer.store";
import { useDocumentsStore } from "../../stores/documents.store";
import { Button } from "../common/Button";
import { cn } from "../../lib/cn";

export function SettingsPanel() {
  const { setActiveView, fontSize, setFontSize } = useUIStore();
  const {
    hasApiKey,
    isEncryptionAvailable,
    sermonsFolder,
    appInfo,
    isLoading,
    error,
    fetchSettings,
    saveApiKey,
    deleteApiKey,
    fetchAppInfo
  } = useSettingsStore();
  const { credits } = useCreditsStore();
  const { selectFolder, indexFolder } = useIndexerStore();
  const { fetchDocuments } = useDocumentsStore();
  
  const [apiKeyInput, setApiKeyInput] = useState("");
  const [showApiKeyInput, setShowApiKeyInput] = useState(false);
  const [saveSuccess, setSaveSuccess] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  
  useEffect(() => {
    fetchSettings();
    fetchAppInfo();
  }, []);
  
  const handleSaveApiKey = async () => {
    setSaveError(null);
    setSaveSuccess(false);
    try {
      await saveApiKey(apiKeyInput);
      setApiKeyInput("");
      setShowApiKeyInput(false);
      setSaveSuccess(true);
      setTimeout(() => setSaveSuccess(false), 3000);
    } catch (err) {
      setSaveError((err as Error).message);
    }
  };
  
  const handleDeleteApiKey = async () => {
    if (confirm("Etes-vous sur de vouloir supprimer la cle API ?")) {
      await deleteApiKey();
    }
  };
  
  const handleChangeFolder = async () => {
    const path = await selectFolder();
    if (path) {
      await indexFolder(path);
      await fetchDocuments();
      await fetchSettings();
    }
  };
  
  return (
    <div className="h-full overflow-y-auto bg-cream">
      <div className="max-w-2xl mx-auto p-6">
        {/* Header */}
        <div className="flex items-center gap-4 mb-8">
          <button
            onClick={() => setActiveView("chat")}
            className="p-2 hover:bg-gray-100 rounded-lg transition-colors"
          >
            <ArrowLeft className="w-5 h-5 text-muted" />
          </button>
          <h1 className="text-2xl font-serif text-burgundy">Parametres</h1>
        </div>
        
        {/* API Key Section */}
        <section className="bg-white rounded-xl p-6 shadow-sm mb-6">
          <div className="flex items-center gap-3 mb-4">
            <Key className="w-5 h-5 text-burgundy" />
            <h2 className="text-lg font-medium">Cle API Anthropic</h2>
          </div>
          
          {hasApiKey ? (
            <div className="space-y-4">
              <div className="flex items-center gap-2 text-green-600">
                <CheckCircle className="w-4 h-4" />
                <span>Cle API configuree</span>
              </div>
              
              {isEncryptionAvailable && (
                <div className="flex items-center gap-2 text-sm text-muted">
                  <Shield className="w-4 h-4" />
                  <span>Stockee de maniere securisee</span>
                </div>
              )}
              
              <div className="flex gap-3">
                <Button
                  variant="secondary"
                  size="sm"
                  onClick={() => setShowApiKeyInput(true)}
                >
                  Modifier
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={handleDeleteApiKey}
                  className="text-red-500 hover:bg-red-50"
                >
                  <Trash2 className="w-4 h-4 mr-1" />
                  Supprimer
                </Button>
              </div>
            </div>
          ) : (
            <div className="space-y-4">
              <p className="text-sm text-muted">
                Pour utiliser l'assistant IA, vous devez configurer votre cle API Anthropic.
                Obtenez-en une sur{" "}
                <a
                  href="https://console.anthropic.com/"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-burgundy hover:underline"
                >
                  console.anthropic.com
                </a>
              </p>
              
              {!showApiKeyInput ? (
                <Button onClick={() => setShowApiKeyInput(true)}>
                  Configurer la cle API
                </Button>
              ) : null}
            </div>
          )}
          
          {showApiKeyInput && (
            <div className="mt-4 space-y-3">
              <input
                type="password"
                value={apiKeyInput}
                onChange={(e) => setApiKeyInput(e.target.value)}
                placeholder="sk-ant-..."
                className="w-full px-4 py-2 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-burgundy/20 focus:border-burgundy"
              />
              
              {saveError && (
                <div className="flex items-center gap-2 text-sm text-red-600">
                  <AlertTriangle className="w-4 h-4" />
                  <span>{saveError}</span>
                </div>
              )}
              
              <div className="flex gap-3">
                <Button
                  onClick={handleSaveApiKey}
                  disabled={!apiKeyInput.trim() || isLoading}
                  isLoading={isLoading}
                >
                  Enregistrer
                </Button>
                <Button
                  variant="ghost"
                  onClick={() => {
                    setShowApiKeyInput(false);
                    setApiKeyInput("");
                    setSaveError(null);
                  }}
                >
                  Annuler
                </Button>
              </div>
            </div>
          )}
          
          {saveSuccess && (
            <div className="mt-4 flex items-center gap-2 text-green-600">
              <CheckCircle className="w-4 h-4" />
              <span>Cle API enregistree avec succes</span>
            </div>
          )}
        </section>
        
        {/* Folder Section */}
        <section className="bg-white rounded-xl p-6 shadow-sm mb-6">
          <div className="flex items-center gap-3 mb-4">
            <Folder className="w-5 h-5 text-burgundy" />
            <h2 className="text-lg font-medium">Dossier de sermons</h2>
          </div>
          
          {sermonsFolder ? (
            <div className="space-y-3">
              <p className="text-sm text-muted break-all">{sermonsFolder}</p>
              <Button variant="secondary" size="sm" onClick={handleChangeFolder}>
                Changer de dossier
              </Button>
            </div>
          ) : (
            <div className="space-y-3">
              <p className="text-sm text-muted">Aucun dossier configure</p>
              <Button onClick={handleChangeFolder}>
                Selectionner un dossier
              </Button>
            </div>
          )}
        </section>
        
        {/* Display Section */}
        <section className="bg-white rounded-xl p-6 shadow-sm mb-6">
          <div className="flex items-center gap-3 mb-4">
            <Type className="w-5 h-5 text-burgundy" />
            <h2 className="text-lg font-medium">Affichage</h2>
          </div>
          
          <div className="space-y-4">
            <div>
              <label className="text-sm text-muted block mb-2">Taille du texte</label>
              <div className="flex gap-2">
                {(["small", "medium", "large"] as const).map((size) => (
                  <button
                    key={size}
                    onClick={() => setFontSize(size)}
                    className={cn(
                      "px-4 py-2 rounded-lg border transition-colors",
                      fontSize === size
                        ? "bg-burgundy text-white border-burgundy"
                        : "bg-white text-gray-700 border-gray-200 hover:border-burgundy"
                    )}
                  >
                    {size === "small" && "Petit"}
                    {size === "medium" && "Moyen"}
                    {size === "large" && "Grand"}
                  </button>
                ))}
              </div>
            </div>
          </div>
        </section>
        
        {/* Credits Section */}
        <section className="bg-white rounded-xl p-6 shadow-sm mb-6">
          <div className="flex items-center gap-3 mb-4">
            <Info className="w-5 h-5 text-burgundy" />
            <h2 className="text-lg font-medium">Credits</h2>
          </div>
          
          <div className="space-y-4">
            <p className="text-2xl font-bold text-burgundy">{credits} credits</p>
            <p className="text-sm text-muted">
              1 credit â‰ˆ 1 question a l'assistant IA
            </p>
            {/* In a real app, this would link to a payment flow */}
            <Button variant="secondary" size="sm" disabled>
              Acheter des credits (bientot disponible)
            </Button>
          </div>
        </section>
        
        {/* About Section */}
        <section className="bg-white rounded-xl p-6 shadow-sm">
          <div className="flex items-center gap-3 mb-4">
            <Info className="w-5 h-5 text-burgundy" />
            <h2 className="text-lg font-medium">A propos</h2>
          </div>
          
          {appInfo && (
            <div className="space-y-2 text-sm text-muted">
              <p><span className="font-medium">Version :</span> {appInfo.version}</p>
              <p><span className="font-medium">Electron :</span> {appInfo.electronVersion}</p>
              <p><span className="font-medium">Chrome :</span> {appInfo.chromeVersion}</p>
              <p><span className="font-medium">Node.js :</span> {appInfo.nodeVersion}</p>
            </div>
          )}
          
          <div className="mt-4 pt-4 border-t border-gray-100 text-sm text-muted">
            <p>Assistant Pastoral - Dialoguez avec vos sermons</p>
            <p className="mt-1">Utilise l'API Claude d'Anthropic</p>
          </div>
        </section>
      </div>
    </div>
  );
}

UPDATE MAIN CONTENT

Update src/renderer/components/layout/MainContent.tsx:

import React from "react";
import { useUIStore } from "../../stores/ui.store";
import { useDocumentsStore } from "../../stores/documents.store";
import { DocumentViewer } from "../documents/DocumentViewer";
import { ChatPanel } from "../chat/ChatPanel";
import { SettingsPanel } from "../settings/SettingsPanel";

export function MainContent() {
  const { activeView } = useUIStore();
  const { selectedDocument } = useDocumentsStore();
  
  if (selectedDocument && activeView === "document") {
    return <DocumentViewer />;
  }
  
  switch (activeView) {
    case "chat":
      return <ChatPanel />;
    case "settings":
      return <SettingsPanel />;
    case "document":
    default:
      if (!selectedDocument) {
        return (
          <div className="h-full flex items-center justify-center text-muted">
            <p>Selectionnez un document dans la liste</p>
          </div>
        );
      }
      return <DocumentViewer />;
  }
}

ONBOARDING COMPONENT

Create src/renderer/components/onboarding/OnboardingModal.tsx:

import React, { useState } from "react";
import { FolderOpen, Key, MessageSquare, ArrowRight, Check } from "lucide-react";
import { Button } from "../common/Button";
import { useSettingsStore } from "../../stores/settings.store";
import { useIndexerStore } from "../../stores/indexer.store";
import { useDocumentsStore } from "../../stores/documents.store";

interface OnboardingModalProps {
  onComplete: () => void;
}

export function OnboardingModal({ onComplete }: OnboardingModalProps) {
  const [step, setStep] = useState(0);
  const [apiKey, setApiKey] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const { saveApiKey } = useSettingsStore();
  const { selectFolder, indexFolder, isIndexing, progress } = useIndexerStore();
  const { fetchDocuments } = useDocumentsStore();
  
  const steps = [
    {
      icon: MessageSquare,
      title: "Bienvenue dans Assistant Pastoral",
      description: "Dialoguez avec vos sermons grace a l'intelligence artificielle. Configurons votre application en quelques etapes."
    },
    {
      icon: Key,
      title: "Cle API Anthropic",
      description: "Pour utiliser l'IA, vous avez besoin d'une cle API Anthropic. Vous pouvez l'obtenir gratuitement sur console.anthropic.com"
    },
    {
      icon: FolderOpen,
      title: "Vos sermons",
      description: "Selectionnez le dossier contenant vos sermons. Les formats PDF, Word, Markdown et ODT sont supportes."
    }
  ];
  
  const handleApiKeySubmit = async () => {
    if (!apiKey.trim()) {
      setStep(2); // Skip if no API key
      return;
    }
    
    setIsLoading(true);
    setError(null);
    try {
      await saveApiKey(apiKey);
      setStep(2);
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleFolderSelect = async () => {
    const path = await selectFolder();
    if (path) {
      await indexFolder(path);
      await fetchDocuments();
      onComplete();
    }
  };
  
  const currentStep = steps[step];
  const Icon = currentStep.icon;
  
  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-white rounded-2xl shadow-xl max-w-lg w-full mx-4 overflow-hidden">
        {/* Progress */}
        <div className="flex">
          {steps.map((_, i) => (
            <div
              key={i}
              className={`flex-1 h-1 ${i <= step ? "bg-burgundy" : "bg-gray-200"}`}
            />
          ))}
        </div>
        
        <div className="p-8">
          {/* Icon */}
          <div className="w-16 h-16 bg-burgundy/10 rounded-full flex items-center justify-center mx-auto mb-6">
            <Icon className="w-8 h-8 text-burgundy" />
          </div>
          
          {/* Content */}
          <h2 className="text-2xl font-serif text-burgundy text-center mb-3">
            {currentStep.title}
          </h2>
          <p className="text-muted text-center mb-6">
            {currentStep.description}
          </p>
          
          {/* Step-specific content */}
          {step === 0 && (
            <Button onClick={() => setStep(1)} className="w-full">
              Commencer
              <ArrowRight className="w-4 h-4 ml-2" />
            </Button>
          )}
          
          {step === 1 && (
            <div className="space-y-4">
              <input
                type="password"
                value={apiKey}
                onChange={(e) => setApiKey(e.target.value)}
                placeholder="sk-ant-..."
                className="w-full px-4 py-3 border border-gray-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-burgundy/20 focus:border-burgundy"
              />
              
              {error && (
                <p className="text-sm text-red-600">{error}</p>
              )}
              
              <div className="flex gap-3">
                <Button
                  variant="secondary"
                  onClick={() => setStep(2)}
                  className="flex-1"
                >
                  Passer
                </Button>
                <Button
                  onClick={handleApiKeySubmit}
                  disabled={isLoading}
                  isLoading={isLoading}
                  className="flex-1"
                >
                  Continuer
                </Button>
              </div>
              
              <p className="text-xs text-center text-muted">
                Vous pourrez configurer la cle API plus tard dans les parametres.
              </p>
            </div>
          )}
          
          {step === 2 && (
            <div className="space-y-4">
              {isIndexing ? (
                <div className="space-y-3">
                  <div className="h-2 bg-gray-200 rounded-full overflow-hidden">
                    <div
                      className="h-full bg-burgundy transition-all duration-300"
                      style={{
                        width: progress
                          ? `${(progress.current / progress.total) * 100}%`
                          : "0%"
                      }}
                    />
                  </div>
                  <p className="text-sm text-center text-muted">
                    {progress
                      ? `Indexation de ${progress.currentFile} (${progress.current}/${progress.total})`
                      : "Preparation..."}
                  </p>
                </div>
              ) : (
                <>
                  <Button onClick={handleFolderSelect} className="w-full">
                    <FolderOpen className="w-4 h-4 mr-2" />
                    Selectionner un dossier
                  </Button>
                  
                  <button
                    onClick={onComplete}
                    className="w-full text-sm text-muted hover:text-burgundy"
                  >
                    Configurer plus tard
                  </button>
                </>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

UPDATE APP TO SHOW ONBOARDING

Update src/renderer/App.tsx:

import React, { useEffect, useState } from "react";
import { MainLayout } from "./components/layout/MainLayout";
import { OnboardingModal } from "./components/onboarding/OnboardingModal";
import { useCreditsStore } from "./stores/credits.store";
import { useSettingsStore } from "./stores/settings.store";
import { useChatStore } from "./stores/chat.store";

export default function App() {
  const [showOnboarding, setShowOnboarding] = useState(false);
  const [isInitialized, setIsInitialized] = useState(false);
  const { fetchCredits } = useCreditsStore();
  const { fetchSettings, hasApiKey, sermonsFolder } = useSettingsStore();
  const { checkApiConfiguration } = useChatStore();
  
  useEffect(() => {
    async function init() {
      await fetchSettings();
      await fetchCredits();
      await checkApiConfiguration();
      setIsInitialized(true);
    }
    init();
  }, []);
  
  useEffect(() => {
    if (isInitialized) {
      // Show onboarding if no API key AND no folder configured
      const needsOnboarding = !hasApiKey && !sermonsFolder;
      setShowOnboarding(needsOnboarding);
    }
  }, [isInitialized, hasApiKey, sermonsFolder]);
  
  const handleOnboardingComplete = () => {
    setShowOnboarding(false);
    fetchSettings();
    checkApiConfiguration();
  };
  
  if (!isInitialized) {
    return (
      <div className="h-screen flex items-center justify-center bg-cream">
        <div className="text-center">
          <div className="w-12 h-12 border-4 border-burgundy border-t-transparent rounded-full animate-spin mx-auto mb-4" />
          <p className="text-muted">Chargement...</p>
        </div>
      </div>
    );
  }
  
  return (
    <>
      <MainLayout />
      {showOnboarding && <OnboardingModal onComplete={handleOnboardingComplete} />}
    </>
  );
}

ERROR BOUNDARY

Create src/renderer/components/common/ErrorBoundary.tsx:

import React, { Component, ErrorInfo, ReactNode } from "react";
import { AlertTriangle, RefreshCw } from "lucide-react";
import { Button } from "./Button";

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
  }

  private handleReload = () => {
    window.location.reload();
  };

  public render() {
    if (this.state.hasError) {
      return (
        <div className="h-screen flex items-center justify-center bg-cream p-8">
          <div className="max-w-md text-center">
            <AlertTriangle className="w-16 h-16 text-red-500 mx-auto mb-4" />
            <h1 className="text-2xl font-serif text-burgundy mb-2">
              Une erreur est survenue
            </h1>
            <p className="text-muted mb-4">
              {this.state.error?.message || "Erreur inconnue"}
            </p>
            <Button onClick={this.handleReload}>
              <RefreshCw className="w-4 h-4 mr-2" />
              Recharger l'application
            </Button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

WRAP APP WITH ERROR BOUNDARY

Update src/renderer/main.tsx:

import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App";
import { ErrorBoundary } from "./components/common/ErrorBoundary";
import "./styles/globals.css";

const root = createRoot(document.getElementById("root")!);
root.render(
  <React.StrictMode>
    <ErrorBoundary>
      <App />
    </ErrorBoundary>
  </React.StrictMode>
);

TOAST NOTIFICATIONS

Create src/renderer/components/common/Toast.tsx:

import React, { useEffect, useState } from "react";
import { CheckCircle, AlertCircle, Info, X } from "lucide-react";
import { cn } from "../../lib/cn";

type ToastType = "success" | "error" | "info";

interface Toast {
  id: string;
  type: ToastType;
  message: string;
}

// Simple toast store
let toasts: Toast[] = [];
let listeners: Array<(toasts: Toast[]) => void> = [];

function notify() {
  listeners.forEach(listener => listener([...toasts]));
}

export function showToast(type: ToastType, message: string) {
  const id = crypto.randomUUID();
  toasts.push({ id, type, message });
  notify();
  
  setTimeout(() => {
    toasts = toasts.filter(t => t.id !== id);
    notify();
  }, 5000);
}

export function ToastContainer() {
  const [currentToasts, setCurrentToasts] = useState<Toast[]>([]);
  
  useEffect(() => {
    listeners.push(setCurrentToasts);
    return () => {
      listeners = listeners.filter(l => l !== setCurrentToasts);
    };
  }, []);
  
  const removeToast = (id: string) => {
    toasts = toasts.filter(t => t.id !== id);
    notify();
  };
  
  const icons = {
    success: CheckCircle,
    error: AlertCircle,
    info: Info
  };
  
  const colors = {
    success: "bg-green-50 border-green-200 text-green-800",
    error: "bg-red-50 border-red-200 text-red-800",
    info: "bg-blue-50 border-blue-200 text-blue-800"
  };
  
  return (
    <div className="fixed bottom-4 right-4 z-50 space-y-2">
      {currentToasts.map(toast => {
        const Icon = icons[toast.type];
        return (
          <div
            key={toast.id}
            className={cn(
              "flex items-center gap-3 px-4 py-3 rounded-lg border shadow-lg animate-slide-up",
              colors[toast.type]
            )}
          >
            <Icon className="w-5 h-5 flex-shrink-0" />
            <span className="flex-1">{toast.message}</span>
            <button
              onClick={() => removeToast(toast.id)}
              className="p-1 hover:bg-black/10 rounded"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        );
      })}
    </div>
  );
}

ADD TOAST TO APP

Add ToastContainer to App.tsx:

import { ToastContainer } from "./components/common/Toast";

// In return:
return (
  <>
    <MainLayout />
    {showOnboarding && <OnboardingModal onComplete={handleOnboardingComplete} />}
    <ToastContainer />
  </>
);

ADD ANIMATIONS TO GLOBALS.CSS

Add to src/renderer/styles/globals.css:

/* Animations */
@keyframes slide-up {
  from {
    transform: translateY(100%);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.animate-slide-up {
  animation: slide-up 0.3s ease-out;
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

.animate-fade-in {
  animation: fade-in 0.2s ease-out;
}

/* Focus styles for accessibility */
*:focus-visible {
  outline: 2px solid #722F37;
  outline-offset: 2px;
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

KEYBOARD NAVIGATION

Add keyboard shortcuts. Create src/renderer/hooks/useKeyboardShortcuts.ts:

import { useEffect } from "react";
import { useUIStore } from "../stores/ui.store";

export function useKeyboardShortcuts() {
  const { toggleSidebar, setActiveView } = useUIStore();
  
  useEffect(() => {
    function handleKeyDown(e: KeyboardEvent) {
      // Ctrl/Cmd + B: Toggle sidebar
      if ((e.ctrlKey || e.metaKey) && e.key === "b") {
        e.preventDefault();
        toggleSidebar();
      }
      
      // Ctrl/Cmd + ,: Open settings
      if ((e.ctrlKey || e.metaKey) && e.key === ",") {
        e.preventDefault();
        setActiveView("settings");
      }
      
      // Escape: Go to chat
      if (e.key === "Escape") {
        setActiveView("chat");
      }
    }
    
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [toggleSidebar, setActiveView]);
}

Use in App.tsx:

import { useKeyboardShortcuts } from "./hooks/useKeyboardShortcuts";

// Inside App component:
useKeyboardShortcuts();

SET APP VERSION

In package.json, ensure version is set:

{
  "version": "1.0.0",
  ...
}

VERIFICATION

After implementation:
1. npm run dev starts without errors
2. Onboarding modal appears on first launch
3. Can configure API key in settings
4. API key is stored securely (encrypted if available)
5. Can change sermon folder from settings
6. Font size changes apply to document viewer
7. About section shows version info
8. Error boundary catches and displays errors
9. Toast notifications work
10. Keyboard shortcuts work (Ctrl+B, Ctrl+,, Escape)
11. App handles missing API key gracefully
12. npm run typecheck passes
13. npm run build creates production build

FINAL CHECKLIST

- [ ] All 6 tasks completed
- [ ] Application starts without errors
- [ ] Can index a folder of sermons
- [ ] Can search documents
- [ ] Can chat with AI about sermons
- [ ] Settings are persisted
- [ ] API key is stored securely
- [ ] Credits are tracked
- [ ] UI is polished and responsive
- [ ] Error handling is comprehensive
- [ ] Production build works
